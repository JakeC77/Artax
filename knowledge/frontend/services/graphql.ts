export type KeyValuePair = { key: string; value: string }
export type GraphNode = { id: string; labels: string[]; properties: KeyValuePair[] }
export type GraphEdge = {
  id: string
  fromId: string
  toId: string
  type?: string | null
  properties?: KeyValuePair[]
}
export type WorkspaceItem = {
  graphNodeId: string
  graphEdgeId?: string | null
}
export type WorkspaceStateValue = 'draft' | 'setup' | 'working' | 'action' | 'archived'

export type Workspace = {
  baseSnapshotTs: string | null
  createdAt: string
  description: string | null
  intent?: string | null
  name: string
  ownerUserId: string | null
  tenantId: string | null
  updatedAt: string
  visibility: string | null
  workspaceId: string
  companyId?: string | null
  ontologyId?: string | null
  setupRunId?: string | null
  setupStage?: string | null
  setupIntentPackage?: IntentPackage | null
  setupDataScope?: DataScope | null
  setupExecutionResults?: ExecutionResult[] | null
  setupTeamConfig?: TeamConfig | null
  state?: WorkspaceStateValue | null
  // Analysis workflow run ID - set when analysis workflow is started after setup
  analysisRunId?: string | null
}

// Workspace Setup Types (per WORKSPACE_SETUP_PLAN.md)
export type IntentPackage = {
  // Versioning
  schema_version?: number  // Currently: 1, defaults to 1 if not present

  // User-editable fields
  title: string
  description?: string           // 100-200 char UI card display
  summary: string               // 2-4 sentence mission summary
  mission: {
    objective: string           // What user wants to accomplish
    why: string                 // Deeper motivation
    success_looks_like: string  // Success criteria
  }

  // AI metadata (not rendered to user in editor, but persisted)
  team_guidance: Record<string, any>
  conversation_transcript?: string
  iteration_history?: Array<{
    version: number
    timestamp: string
    change_description: string
    user_feedback?: string
  }>
  current_version?: number
  created_at?: string  // ISO datetime
  confirmed: boolean
}

export type DataScopeFieldOfInterest = {
  field: string
  justification: string
}

export type DataScopeEntity = {
  entity_type: string
  reasoning: string
  filters: any[]
  estimated_count: number
  // Additional fields from scope_update event
  relevance_level?: 'primary' | 'related' | 'contextual'
  fields_of_interest?: DataScopeFieldOfInterest[]
  // Cypher query for fetching this entity's data (generated by AI)
  query?: string
}

export type DataScope = {
  scopes: DataScopeEntity[]
  // Additional metadata from scope_update event
  relationships?: Array<{
    from_entity: string
    to_entity: string
    relationship_type: string
    reasoning?: string
  }>
  summary?: string
  confidence?: 'low' | 'medium' | 'high'
}

export type ExecutionResult = {
  entity_type: string
  node_ids: string[]
  sample_data: any[]
  total_count: number
}

export type TeamConfig = {
  team_id: string
  team_name?: string
  conductor?: {
    agent_id: string
    name: string
    role: string
    capabilities: string[]
  }
  agents: Array<{
    agent_id: string
    name?: string
    role: string
    type?: 'conductor' | 'specialist' | string
    capabilities: string[]
  }>
}

export type SetupStage = 'intent_discovery' | 'data_scoping' | 'data_review' | 'team_building' | 'complete'

export type SetupStatus = {
  workspaceId: string
  stage: SetupStage
  runId?: string | null
  intentPackage?: IntentPackage | null
  dataScope?: DataScope | null
  executionResults?: ExecutionResult[] | null
  teamConfig?: TeamConfig | null
}

export type StageTransitionResult = {
  runId: string
  stage: SetupStage
}

export type User = { userId: string; displayName: string; email: string }
export type Tenant = { tenantId: string; name: string; region: string }
export type AiTeam = {
  aiTeamId: string
  workspaceId: string
  name: string
  description: string | null
  createdAt: string
  updatedAt: string
}
export type AiTeamMember = {
  aiTeamMemberId: string
  aiTeamId: string
  agentId: string
  name: string
  description: string | null
  role: string
  systemPrompt: string
  model: string | null
  temperature: number | null
  maxTokens: number | null
  tools: string[]
  expertise: string[]
  communicationStyle: string | null
  createdAt: string
  updatedAt: string
  team: AiTeam | null
}
export type ScratchpadNote = {
  scratchpadNoteId: string
  workspaceId: string
  title: string | null
  text: string | null
  createdOn: string
}
export type ScratchpadAttachment = {
  scratchpadAttachmentId: string
  workspaceId: string
  title: string | null
  description: string | null
  uri: string
  size: number | null
  fileType: string | null
  createdOn: string
  processingStatus?: string | null
  processingError?: string | null
}

export type DocumentEntity = {
  document_entity_name: string
  domain_entity?: {
    nodeId: string
    nodeType: string
    nodeName?: string
  } | null
}

export type ScratchpadAttachmentAssertion = {
  source_entity: DocumentEntity
  assertion: string
  terminal_entity: DocumentEntity
  source: string
  source_url: string
  domain_edge_type?: string | null
}

export type DataLoadingAttachment = {
  attachmentId: string
  tenantId: string
  ontologyId: string
  fileName: string
  blobPath: string | null
  uri: string | null
  createdOn: string
  createdBy: string | null
  runId: string | null
  status: string | null
}

export type StartDataLoadingResult = {
  runId: string | null
  success: boolean
}

export type GraphPropertyMatchInput = {
  property: string
  value: string
  fuzzySearch: boolean
  maxDistance: number
}

export type GraphFilterInput = {
  property: string
  value: string
  fuzzySearch: boolean
  maxDistance: number
}

export type GraphFilterGroupInput = {
  operator: 'OR' | 'AND'
  filters: GraphFilterInput[]
}

export type GraphNodePropertyMetadata = {
  name: string
  dataType: string
}

export type SemanticEntity = {
  semanticEntityId: string
  tenantId: string
  nodeLabel: string
  version: number
  name: string
  description: string | null
  createdOn: string
}

export type SemanticField = {
  semanticFieldId: string
  semanticEntityId: string
  version: number
  name: string
  description: string | null
}

import { msalInstance } from '../contexts/AuthContext'
import { loginRequest } from '../config/msalConfig'
import type { AccountInfo } from '@azure/msal-browser'
import type {
  ReportTemplate,
  Report,
  RichTextContent,
  SingleMetricContent,
  MultiMetricContent,
  InsightCardContent,
} from '../types/reports'

// Re-export report types for external use
export type { Report, ReportTemplate }

const DEFAULT_URL = 'https://app-sbx-westus3-01.azurewebsites.net/gql'

const GRAPHQL_URL = import.meta.env.VITE_GRAPHQL_URL || DEFAULT_URL

let TENANT_ID: string | undefined = import.meta.env.VITE_TENANT_ID || undefined

export function setTenantId(id?: string) {
  TENANT_ID = id || undefined
}

export function getTenantId(): string | undefined {
  return 'e7d347f1-ea8c-4933-9807-29f19a9237e7'
}

export function getApiBase(): string {
  const url = (GRAPHQL_URL || '').replace(/\/$/, '')
  return url.replace(/\/?gql$/i, '')
}

// Custom EventSource that supports authentication headers
// Since native EventSource doesn't support custom headers, we use fetch with streaming
export class AuthenticatedEventSource {
  private _url: string
  private headers: Record<string, string>
  private fetchController: AbortController | null = null
  private listeners: Map<string, Set<(event: MessageEvent) => void>> = new Map()
  private _readyState: number = 0 // CONNECTING
  private lastEventId: string | null = null

  // EventSource constants
  static readonly CONNECTING = 0
  static readonly OPEN = 1
  static readonly CLOSED = 2

  constructor(url: string, options?: { headers?: Record<string, string> }) {
    this._url = url
    this.headers = options?.headers || {}
    this.connect()
  }

  private async connect() {
    try {
      // Get access token for authentication
      const accessToken = await getAccessToken()
      
      const headers: Record<string, string> = {
        ...this.headers,
        ...(TENANT_ID ? { 'X-Tenant-Id': TENANT_ID } : {}),
        ...(accessToken ? { Authorization: `Bearer ${accessToken}` } : {}),
        Accept: 'text/event-stream',
      }

      // If we have a lastEventId, include it in headers for reconnection
      if (this.lastEventId) {
        headers['Last-Event-ID'] = this.lastEventId
      }

      this.fetchController = new AbortController()
      const response = await fetch(this.url, {
        method: 'GET',
        headers,
        signal: this.fetchController.signal,
      })

      if (!response.ok) {
        throw new Error(`EventSource failed: ${response.status} ${response.statusText}`)
      }

      this._readyState = AuthenticatedEventSource.OPEN
      this.dispatchEvent(new MessageEvent('open'))

      const reader = response.body?.getReader()
      if (!reader) {
        throw new Error('Response body is not readable')
      }

      const decoder = new TextDecoder()
      let buffer = ''

      while (true) {
        const { done, value } = await reader.read()
        
        if (done) {
          break
        }

        buffer += decoder.decode(value, { stream: true })
        
        // Process complete events (separated by double newline)
        while (buffer.includes('\n\n')) {
          const eventEnd = buffer.indexOf('\n\n')
          const eventText = buffer.substring(0, eventEnd)
          buffer = buffer.substring(eventEnd + 2)

          let eventType = 'message'
          let eventData = ''
          let eventId: string | null = null

          const lines = eventText.split('\n')
          for (const line of lines) {
            if (line.startsWith('event:')) {
              eventType = line.substring(6).trim()
            } else if (line.startsWith('data:')) {
              const data = line.substring(5)
              // Remove leading space if present (SSE spec allows it)
              eventData += (eventData ? '\n' : '') + (data.startsWith(' ') ? data.substring(1) : data)
            } else if (line.startsWith('id:')) {
              eventId = line.substring(3).trim()
              this.lastEventId = eventId
            } else if (line.startsWith('retry:')) {
              // Handle retry directive if needed
            }
          }

          // Dispatch event if we have data
          if (eventData) {
            const event = new MessageEvent(eventType, {
              data: eventData,
              lastEventId: eventId || undefined,
            })
            this.dispatchEvent(event)
          }
        }
      }

      // Handle any remaining data in buffer (incomplete event)
      if (buffer.trim()) {
        // Try to parse as a simple message event
        const event = new MessageEvent('message', {
          data: buffer.trim(),
        })
        this.dispatchEvent(event)
      }

      this._readyState = AuthenticatedEventSource.CLOSED
      this.dispatchEvent(new MessageEvent('error'))
    } catch (error: any) {
      if (error.name === 'AbortError') {
        // Connection was intentionally closed
        return
      }
      this._readyState = AuthenticatedEventSource.CLOSED
      this.dispatchEvent(new MessageEvent('error', { data: error.message }))
    }
  }

  private dispatchEvent(event: MessageEvent) {
    const listeners = this.listeners.get(event.type) || new Set()
    listeners.forEach((listener) => {
      try {
        listener(event)
      } catch (error) {
        console.error('Error in EventSource listener:', error)
      }
    })
  }

  addEventListener(type: string, listener: (event: MessageEvent) => void) {
    if (!this.listeners.has(type)) {
      this.listeners.set(type, new Set())
    }
    this.listeners.get(type)!.add(listener)
  }

  removeEventListener(type: string, listener: (event: MessageEvent) => void) {
    const listeners = this.listeners.get(type)
    if (listeners) {
      listeners.delete(listener)
    }
  }

  // Convenience properties for compatibility with native EventSource
  set onopen(handler: ((event: MessageEvent) => void) | null) {
    if (handler) {
      this.addEventListener('open', handler)
    }
  }

  set onmessage(handler: ((event: MessageEvent) => void) | null) {
    if (handler) {
      this.addEventListener('message', handler)
    }
  }

  set onerror(handler: ((event: MessageEvent) => void) | null) {
    if (handler) {
      this.addEventListener('error', handler)
    }
  }

  get readyState(): number {
    return this._readyState
  }

  get url(): string {
    return this._url
  }

  get withCredentials(): boolean {
    return false
  }

  close() {
    if (this.fetchController) {
      this.fetchController.abort()
      this.fetchController = null
    }
    this._readyState = AuthenticatedEventSource.CLOSED
    this.listeners.clear()
  }
}

// Helper function to download a file with authentication headers
export async function downloadFile(url: string, filename?: string): Promise<void> {
  const accessToken = await getAccessToken()
  
  const headers: Record<string, string> = {
    ...(TENANT_ID ? { 'X-Tenant-Id': TENANT_ID } : {}),
    ...(accessToken ? { Authorization: `Bearer ${accessToken}` } : {}),
  }

  const response = await fetch(url, {
    method: 'GET',
    headers,
    mode: 'cors',
  })

  if (!response.ok) {
    throw new Error(`Failed to download file: ${response.status} ${response.statusText}`)
  }

  const blob = await response.blob()
  const blobUrl = window.URL.createObjectURL(blob)
  
  const link = document.createElement('a')
  link.href = blobUrl
  link.download = filename || 'download'
  document.body.appendChild(link)
  link.click()
  document.body.removeChild(link)
  window.URL.revokeObjectURL(blobUrl)
}

// Helper function to open a file in a new window/tab with authentication headers
export async function openFileInNewWindow(url: string): Promise<void> {
  const accessToken = await getAccessToken()
  
  const headers: Record<string, string> = {
    ...(TENANT_ID ? { 'X-Tenant-Id': TENANT_ID } : {}),
    ...(accessToken ? { Authorization: `Bearer ${accessToken}` } : {}),
  }

  const response = await fetch(url, {
    method: 'GET',
    headers,
    mode: 'cors',
  })

  if (!response.ok) {
    throw new Error(`Failed to load file: ${response.status} ${response.statusText}`)
  }

  const blob = await response.blob()
  const blobUrl = window.URL.createObjectURL(blob)
  const newWindow = window.open(blobUrl, '_blank', 'noopener,noreferrer')
  
  // Clean up blob URL after a delay (give the browser time to load it)
  setTimeout(() => {
    window.URL.revokeObjectURL(blobUrl)
  }, 1000)
  
  if (!newWindow) {
    window.URL.revokeObjectURL(blobUrl)
    throw new Error('Failed to open file: popup blocked')
  }
}

type GraphQLResponse<T> = {
  data?: T
  errors?: { message: string }[]
}

// Helper function to get access token
async function getAccessToken(): Promise<string | null> {
  try {
    const accounts = msalInstance.getAllAccounts()
    if (accounts.length === 0) {
      console.warn('No accounts found - user may not be authenticated')
      return null
    }

    const account = accounts[0] as AccountInfo

    try {
      // Try to get token silently first
      const response = await msalInstance.acquireTokenSilent({
        ...loginRequest,
        account: account,
      })
      console.debug('Token acquired silently')
      return response.accessToken
    } catch (error: any) {
      // If silent token acquisition fails, try popup
      if (error.errorCode === 'interaction_required' || error.errorCode === 'consent_required') {
        console.warn('Silent token acquisition requires interaction, attempting popup...')
        try {
          const response = await msalInstance.acquireTokenPopup({
            ...loginRequest,
            account: account,
          })
          console.debug('Token acquired via popup')
          return response.accessToken
        } catch (popupError: any) {
          console.error('Token acquisition popup failed:', popupError.errorCode || popupError.message || popupError)
          return null
        }
      }
      console.error('Silent token acquisition failed:', error.errorCode || error.message || error)
      return null
    }
  } catch (error: any) {
    console.error('Error getting access token:', error.message || error)
    return null
  }
}

async function request<T>(query: string, variables?: Record<string, any>): Promise<T> {
  const accessToken = await getAccessToken()
  
  if (!accessToken) {
    console.warn('No access token available for GraphQL request')
  } else {
    console.debug('Including Bearer token in request')
  }
  
  const headers: Record<string, string> = {
    'Content-Type': 'application/json',
    ...(TENANT_ID ? { 'X-Tenant-Id': TENANT_ID } : {}),
    ...(accessToken ? { Authorization: `Bearer ${accessToken}` } : {}),
  }

  const res = await fetch(GRAPHQL_URL, {
    method: 'POST',
    headers,
    body: JSON.stringify({ query, variables }),
    mode: 'cors',
  })

  // Handle 401 Unauthorized - token might be expired
  if (res.status === 401 && accessToken) {
    // Try to refresh token and retry once
    const refreshedToken = await getAccessToken()
    if (refreshedToken && refreshedToken !== accessToken) {
      const retryHeaders: Record<string, string> = {
        'Content-Type': 'application/json',
        ...(TENANT_ID ? { 'X-Tenant-Id': TENANT_ID } : {}),
        Authorization: `Bearer ${refreshedToken}`,
      }
      const retryRes = await fetch(GRAPHQL_URL, {
        method: 'POST',
        headers: retryHeaders,
        body: JSON.stringify({ query, variables }),
        mode: 'cors',
      })
      if (!retryRes.ok) {
        const text = await retryRes.text().catch(() => '')
        throw new Error(`GraphQL HTTP ${retryRes.status}: ${text}`)
      }
      const json = (await retryRes.json()) as GraphQLResponse<T>
      if (json.errors && json.errors.length) {
        throw new Error(json.errors.map((e) => e.message).join('; '))
      }
      if (!json.data) {
        throw new Error('GraphQL: Empty response data')
      }
      return json.data
    }
  }

  if (!res.ok) {
    const text = await res.text().catch(() => '')
    throw new Error(`GraphQL HTTP ${res.status}: ${text}`)
  }

  const json = (await res.json()) as GraphQLResponse<T>
  if (json.errors && json.errors.length) {
    throw new Error(json.errors.map((e) => e.message).join('; '))
  }
  if (!json.data) {
    throw new Error('GraphQL: Empty response data')
  }
  return json.data
}

// Multipart GraphQL (for Upload scalar)
async function requestMultipart<T>(query: string, variables: Record<string, any>, fileVarPath = 'file'): Promise<T> {
  const accessToken = await getAccessToken()
  
  const form = new FormData()
  const opsVars: Record<string, any> = { ...variables }
  const fileObj = opsVars[fileVarPath]
  opsVars[fileVarPath] = null
  form.append('operations', JSON.stringify({ query, variables: opsVars }))
  form.append('map', JSON.stringify({ '0': ['variables.' + fileVarPath] }))
  form.append('0', fileObj)
  
  const headers: Record<string, string> = {
    ...(TENANT_ID ? { 'X-Tenant-Id': TENANT_ID } : {}),
    ...(accessToken ? { Authorization: `Bearer ${accessToken}` } : {}),
  }
  
  const res = await fetch(GRAPHQL_URL, {
    method: 'POST',
    headers,
    body: form,
    mode: 'cors',
  })
  
  // Handle 401 Unauthorized - token might be expired
  if (res.status === 401 && accessToken) {
    // Try to refresh token and retry once
    const refreshedToken = await getAccessToken()
    if (refreshedToken && refreshedToken !== accessToken) {
      // Recreate FormData for retry (FormData can only be read once)
      const retryForm = new FormData()
      const retryOpsVars: Record<string, any> = { ...variables }
      const retryFileObj = retryOpsVars[fileVarPath]
      retryOpsVars[fileVarPath] = null
      retryForm.append('operations', JSON.stringify({ query, variables: retryOpsVars }))
      retryForm.append('map', JSON.stringify({ '0': ['variables.' + fileVarPath] }))
      retryForm.append('0', retryFileObj)
      
      const retryHeaders: Record<string, string> = {
        ...(TENANT_ID ? { 'X-Tenant-Id': TENANT_ID } : {}),
        Authorization: `Bearer ${refreshedToken}`,
      }
      const retryRes = await fetch(GRAPHQL_URL, {
        method: 'POST',
        headers: retryHeaders,
        body: retryForm,
        mode: 'cors',
      })
      if (!retryRes.ok) {
        const text = await retryRes.text().catch(() => '')
        throw new Error('GraphQL HTTP ' + retryRes.status + ': ' + text)
      }
      const json = (await retryRes.json()) as GraphQLResponse<T>
      if (json.errors && json.errors.length) {
        throw new Error(json.errors.map((e) => e.message).join('; '))
      }
      if (!json.data) {
        throw new Error('GraphQL: Empty response data')
      }
      return json.data
    }
  }
  
  if (!res.ok) {
    const text = await res.text().catch(() => '')
    throw new Error('GraphQL HTTP ' + res.status + ': ' + text)
  }
  const json = (await res.json()) as GraphQLResponse<T>
  if (json.errors && json.errors.length) {
    throw new Error(json.errors.map((e) => e.message).join('; '))
  }
  if (!json.data) {
    throw new Error('GraphQL: Empty response data')
  }
  return json.data
}

export async function fetchGraphNodePropertyMetadata(type: string): Promise<GraphNodePropertyMetadata[]> {
  const q = `query NodePropertyMetadata($type: String!) {
    graphNodePropertyMetadata(type: $type) { name dataType }
  }`
  const data = await request<{ graphNodePropertyMetadata: GraphNodePropertyMetadata[] }>(q, { type })
  return data.graphNodePropertyMetadata ?? []
}

export async function fetchGraphNodeRelationshipTypes(type: string): Promise<string[]> {
  const q = `query NodeRelationshipTypes($type: String!) { graphNodeRelationshipTypes(type: $type) }`
  const data = await request<{ graphNodeRelationshipTypes: string[] }>(q, { type })
  return data.graphNodeRelationshipTypes ?? []
}

export async function fetchSemanticEntityByNodeLabel(nodeLabel: string): Promise<SemanticEntity | null> {
  const q = `query SemanticEntityByNodeLabel($nodeLabel: String!) {
    semanticEntities(
      where: { nodeLabel: { eq: $nodeLabel } }
      order: [{ version: DESC }, { createdOn: DESC }]
    ) {
      semanticEntityId
      tenantId
      nodeLabel
      version
      name
      description
      createdOn
    }
  }`
  const data = await request<{ semanticEntities: SemanticEntity[] }>(q, { nodeLabel })
  return data.semanticEntities?.[0] ?? null
}

export async function createSemanticEntity({
  tenantId,
  nodeLabel,
  name,
  description,
  version,
}: {
  tenantId: string
  nodeLabel: string
  name: string
  description?: string
  version?: number
}): Promise<string> {
  const q = `mutation CreateSemanticEntity(
    $tenantId: UUID!
    $nodeLabel: String!
    $name: String!
    $description: String
    $version: Int
  ) {
    createSemanticEntity(
      tenantId: $tenantId
      nodeLabel: $nodeLabel
      name: $name
      description: $description
      version: $version
    )
  }`
  const data = await request<{ createSemanticEntity: string }>(q, {
    tenantId,
    nodeLabel,
    name,
    description,
    version,
  })
  return data.createSemanticEntity
}

export async function updateSemanticEntity({
  semanticEntityId,
  nodeLabel,
  name,
  description,
  version,
}: {
  semanticEntityId: string
  nodeLabel?: string
  name?: string
  description?: string
  version?: number
}): Promise<boolean> {
  const q = `mutation UpdateSemanticEntity(
    $semanticEntityId: UUID!
    $nodeLabel: String
    $name: String
    $description: String
    $version: Int
  ) {
    updateSemanticEntity(
      semanticEntityId: $semanticEntityId
      nodeLabel: $nodeLabel
      name: $name
      description: $description
      version: $version
    )
  }`
  const data = await request<{ updateSemanticEntity: boolean }>(q, {
    semanticEntityId,
    nodeLabel,
    name,
    description,
    version,
  })
  return !!data.updateSemanticEntity
}

export async function getOrCreateSemanticEntity(nodeLabel: string): Promise<SemanticEntity> {
  const existing = await fetchSemanticEntityByNodeLabel(nodeLabel)
  if (existing) {
    return existing
  }

  const tenantId = getTenantId()
  if (!tenantId) {
    throw new Error('Tenant ID is required to create semantic entities')
  }

  await createSemanticEntity({
    tenantId,
    nodeLabel,
    name: nodeLabel,
    description: '',
    version: 1,
  })

  const created = await fetchSemanticEntityByNodeLabel(nodeLabel)
  if (!created) {
    throw new Error('Failed to load semantic entity after creation')
  }
  return created
}

export async function fetchSemanticFields(semanticEntityId: string): Promise<SemanticField[]> {
  const q = `query SemanticFields($semanticEntityId: UUID!) {
    semanticFields(
      where: { semanticEntityId: { eq: $semanticEntityId } }
      order: [{ name: ASC }]
    ) {
      semanticFieldId
      semanticEntityId
      version
      name
      description
    }
  }`
  const data = await request<{ semanticFields: SemanticField[] }>(q, { semanticEntityId })
  return data.semanticFields ?? []
}

export async function createSemanticField({
  semanticEntityId,
  name,
  description,
  version,
}: {
  semanticEntityId: string
  name: string
  description?: string
  version?: number
}): Promise<string> {
  const q = `mutation CreateSemanticField(
    $semanticEntityId: UUID!
    $name: String!
    $description: String
    $version: Int
  ) {
    createSemanticField(
      semanticEntityId: $semanticEntityId
      name: $name
      description: $description
      version: $version
    )
  }`
  const data = await request<{ createSemanticField: string }>(q, {
    semanticEntityId,
    name,
    description,
    version,
  })
  return data.createSemanticField
}

export async function updateSemanticField({
  semanticFieldId,
  name,
  description,
  version,
}: {
  semanticFieldId: string
  name?: string
  description?: string
  version?: number
}): Promise<boolean> {
  const q = `mutation UpdateSemanticField(
    $semanticFieldId: UUID!
    $name: String
    $description: String
    $version: Int
  ) {
    updateSemanticField(
      semanticFieldId: $semanticFieldId
      name: $name
      description: $description
      version: $version
    )
  }`
  const data = await request<{ updateSemanticField: boolean }>(q, {
    semanticFieldId,
    name,
    description,
    version,
  })
  return !!data.updateSemanticField
}

export async function fetchGraphNodeTypes(): Promise<string[]> {
  const q = `query NodeTypes { graphNodeTypes }`
  const data = await request<{ graphNodeTypes: string[] }>(q)
  return data.graphNodeTypes
}

export async function fetchGraphNodesByType(type: string): Promise<GraphNode[]> {
  const q = `query NodesByType($type: String!) { graphNodesByType(type: $type) { id labels properties { key value } } }`
  const data = await request<{ graphNodesByType: GraphNode[] }>(q, { type })
  return data.graphNodesByType
}

// Type for search results where properties is an object
export type GraphNodeSearchResult = {
  id: string
  labels: string[]
  properties: Record<string, any>
}

export async function fetchGraphNodesByFuzzySearch(
  criteria: GraphPropertyMatchInput[],
  nodeType?: string | null
): Promise<GraphNodeSearchResult[]> {
  const q = `query FuzzySearchByType($criteria: [GraphPropertyMatchInput!]!, $type: String) {
    graphNodesSearch(criteria: $criteria, type: $type) {
      id
      labels
      properties {
        key
        value
      }
    }
  }`
  const data = await request<{ graphNodesSearch: GraphNodeSearchResult[] }>(q, {
    criteria,
    type: nodeType || null,
  })
  // Convert properties from KeyValuePair[] to Record<string, any>
  const results = (data.graphNodesSearch ?? []).map((node) => ({
    ...node,
    properties: (node.properties as any).reduce((acc: Record<string, any>, kv: { key: string; value: any }) => {
      acc[kv.key] = kv.value
      return acc
    }, {}),
  }))
  return results
}

export async function fetchGraphNodesByFuzzySearchOr(
  filterGroup: GraphFilterGroupInput,
  nodeType?: string | null,
  ontologyId?: string | null
): Promise<GraphNodeSearchResult[]> {
  const q = `query FuzzySearchOr($filterGroup: GraphFilterGroupInput!, $type: String, $ontologyId: UUID) {
    graphNodesSearchWithFilters(filterGroup: $filterGroup, type: $type, ontologyId: $ontologyId) {
      id
      labels
      properties {
        key
        value
      }
    }
  }`
  const data = await request<{ graphNodesSearchWithFilters: GraphNodeSearchResult[] }>(q, {
    filterGroup,
    type: nodeType || null,
    ontologyId: ontologyId || null,
  })
  // Convert properties from KeyValuePair[] to Record<string, any>
  const results = (data.graphNodesSearchWithFilters ?? []).map((node) => ({
    ...node,
    properties: (node.properties as any).reduce((acc: Record<string, any>, kv: { key: string; value: any }) => {
      acc[kv.key] = kv.value
      return acc
    }, {}),
  }))
  return results
}

/**
 * Execute a Cypher query and return graph nodes.
 * Used for entity preview data fetching.
 */
export async function fetchGraphNodesByCypher(cypherQuery: string): Promise<GraphNode[]> {
  const q = `query NodesByCypher($cypherQuery: String!) {
    graphNodesByCypher(cypherQuery: $cypherQuery) {
      id
      labels
      properties { key value }
    }
  }`
  const data = await request<{ graphNodesByCypher: GraphNode[] }>(q, { cypherQuery })
  return data.graphNodesByCypher ?? []
}

/**
 * Parse JSON fields in workspace object that may be returned as strings from GraphQL.
 * The backend stores these as JSONB but GraphQL may return them as JSON strings.
 */
function parseWorkspaceJsonFields(ws: Workspace): Workspace {
  const parsed = { ...ws }

  // Parse setupIntentPackage if it's a string
  if (typeof parsed.setupIntentPackage === 'string') {
    try {
      parsed.setupIntentPackage = JSON.parse(parsed.setupIntentPackage)
    } catch (e) {
      console.warn('[GraphQL] Failed to parse setupIntentPackage:', e)
      parsed.setupIntentPackage = null
    }
  }

  // Parse setupDataScope if it's a string
  if (typeof parsed.setupDataScope === 'string') {
    try {
      parsed.setupDataScope = JSON.parse(parsed.setupDataScope)
    } catch (e) {
      console.warn('[GraphQL] Failed to parse setupDataScope:', e)
      parsed.setupDataScope = null
    }
  }

  // Parse setupExecutionResults if it's a string
  if (typeof parsed.setupExecutionResults === 'string') {
    try {
      parsed.setupExecutionResults = JSON.parse(parsed.setupExecutionResults)
    } catch (e) {
      console.warn('[GraphQL] Failed to parse setupExecutionResults:', e)
      parsed.setupExecutionResults = null
    }
  }

  // Parse setupTeamConfig if it's a string
  if (typeof parsed.setupTeamConfig === 'string') {
    try {
      parsed.setupTeamConfig = JSON.parse(parsed.setupTeamConfig)
    } catch (e) {
      console.warn('[GraphQL] Failed to parse setupTeamConfig:', e)
      parsed.setupTeamConfig = null
    }
  }

  return parsed
}

export async function fetchWorkspaces(): Promise<Workspace[]> {
  const q = `query Workspaces { workspaces { baseSnapshotTs createdAt description intent name ownerUserId tenantId updatedAt visibility workspaceId companyId ontologyId setupRunId setupStage setupIntentPackage setupDataScope setupExecutionResults setupTeamConfig state } }`
  const data = await request<{ workspaces: Workspace[] }>(q)
  return data.workspaces.map(parseWorkspaceJsonFields)
}

export async function fetchWorkspaceById(workspaceId: string): Promise<Workspace | null> {
  const q = `query Workspace($workspaceId: UUID!) {
    workspaces(where: { workspaceId: { eq: $workspaceId } }) {
      baseSnapshotTs createdAt description intent name ownerUserId tenantId updatedAt visibility workspaceId companyId ontologyId setupRunId setupStage setupIntentPackage setupDataScope setupExecutionResults setupTeamConfig state
    }
  }`
  const data = await request<{ workspaces: Workspace[] }>(q, { workspaceId })
  const workspace = data.workspaces?.[0]
  return workspace ? parseWorkspaceJsonFields(workspace) : null
}

export async function fetchWorkspaceItems(workspaceId: string): Promise<WorkspaceItem[]> {
  const q = `query WorkspaceItems($workspaceId: UUID!) {
    workspaceItems(where: { workspaceId: { eq: $workspaceId } }, order: [{ pinnedAt: ASC }]) {
      workspaceItemId
      workspaceId
      graphNodeId
      graphEdgeId
      labels
      pinnedBy
      pinnedAt
    }
  }`
  const data = await request<{ workspaceItems: WorkspaceItem[] }>(q, { workspaceId })
  return data.workspaceItems
}

export async function fetchGraphNodeById(id: string): Promise<GraphNode | null> {
  const q = `query graphNodeById($id: String!) { graphNodeById(id: $id) { id labels properties { key value } } }`
  const data = await request<{ graphNodeById: GraphNode | null }>(q, { id })
  return data.graphNodeById ?? null
}

export async function fetchGraphEdgeById(id: string): Promise<GraphEdge | null> {
  const q = `query graphEdgeById($id: String!) { graphEdgeById(id: $id) { id fromId toId type properties { key value } } }`
  const data = await request<{ graphEdgeById: GraphEdge | null }>(q, { id })
  return data.graphEdgeById ?? null
}

export async function fetchNeighbors(nodeId: string): Promise<{ nodes: GraphNode[]; edges: GraphEdge[] }> {
  const q = `query Neighbors($id: String!) {
    graphNeighbors(id: $id) {
      nodes { id labels properties { key value } }
      edges { id fromId toId type properties { key value } }
    }
  }`
  const data = await request<{ graphNeighbors: { nodes: GraphNode[]; edges: GraphEdge[] } }>(q, { id: nodeId })
  return data.graphNeighbors
}

export async function fetchUsers(): Promise<User[]> {
  const q = `query Users { users(order: [{ displayName: ASC }]) { userId displayName email } }`
  const data = await request<{ users: User[] }>(q)
  return data.users ?? []
}

export async function fetchTenants(): Promise<Tenant[]> {
  const q = `query Tenants { tenants(order: [{ name: ASC }]) { tenantId name region } }`
  const data = await request<{ tenants: Tenant[] }>(q)
  return data.tenants ?? []
}

export async function createScenario(args: {
  workspaceId: string
  name: string
  createdBy: string
  relatedChangesetId?: string
}): Promise<string> {
  const q = `mutation CreateScenario($workspaceId: UUID!, $name: String!, $createdBy: UUID!, $relatedChangesetId: UUID) {
    createScenario(workspaceId: $workspaceId, name: $name, createdBy: $createdBy, relatedChangesetId: $relatedChangesetId)
  }`
  const data = await request<{ createScenario: string }>(q, args)
  const id = data.createScenario
  if (!id) throw new Error('No scenarioId returned')
  return id
}

export async function createScenarioRun(
  scenarioId: string,
  inputs?: any,
  prompt?: string,
  engine = 'ai:workspace-analyzer'
): Promise<string> {
  const q = `mutation CreateRun($scenarioId: UUID!, $engine: String!, $inputs: String, $prompt: String) {
    createScenarioRun(scenarioId: $scenarioId, engine: $engine, inputs: $inputs, prompt: $prompt)
  }`
  const variables = { scenarioId, engine, inputs: JSON.stringify(inputs ?? {}), prompt }
  const data = await request<{ createScenarioRun: string }>(q, variables)
  const runId = data.createScenarioRun
  if (!runId) throw new Error('No runId returned')
  return runId
}

// Analysis Workflow Types
export interface AnalysisWorkflowInputs {
  intent_package: {
    objective: string
    focus_areas: string[]
    key_questions?: string[]
    constraints?: {
      timeline?: string
      budget_target?: string
      [key: string]: string | undefined
    }
  }
  data_inventory: {
    entities: string[]
    record_counts: Record<string, number>
    relationships?: string[]
    sample_data?: Record<string, unknown>
  }
}

export interface AnalysisWorkflowRunResult {
  runId: string
  status: string
  requestedAt?: string
}

// Start analysis workflow - creates scenario and run in one step
export async function startAnalysisWorkflow(
  workspaceId: string,
  inputs: AnalysisWorkflowInputs
): Promise<AnalysisWorkflowRunResult> {
  // First create a scenario for this analysis
  const scenarioId = await createScenario({
    workspaceId,
    name: `Analysis - ${new Date().toISOString()}`,
    createdBy: 'e7d347f1-ea8c-4933-9807-29f19a9237e7', // System user
  })

  // Then create the run with the analysis workflow engine
  const runId = await createScenarioRun(
    scenarioId,
    inputs,
    undefined,
    'ai:analysis-workflow'
  )

  return {
    runId,
    status: 'pending',
    requestedAt: new Date().toISOString(),
  }
}

// Cancel a running analysis workflow
export async function cancelAnalysisWorkflow(runId: string): Promise<boolean> {
  const q = `mutation CancelScenarioRun($runId: UUID!) {
    updateScenarioRun(runId: $runId, status: "cancelled")
  }`
  const data = await request<{ updateScenarioRun: boolean }>(q, { runId })
  return !!data.updateScenarioRun
}

// Fetch scenario run status
export async function fetchScenarioRunStatus(runId: string): Promise<{
  runId: string
  status: string
  outputs?: any
}> {
  const q = `query GetScenarioRun($runId: UUID!) {
    scenarioRun(runId: $runId) {
      runId
      status
      outputs
    }
  }`
  const data = await request<{ scenarioRun: { runId: string; status: string; outputs?: any } }>(q, { runId })
  return data.scenarioRun
}

export async function fetchAiTeamMembers(workspaceId: string): Promise<AiTeamMember[]> {
  const q = `query GetAITeamMembersByWorkspace($workspaceId: UUID!) {
    aiTeamMembers(where: { team: { workspaceId: { eq: $workspaceId } } }) {
      aiTeamMemberId
      aiTeamId
      agentId
      name
      description
      role
      systemPrompt
      model
      temperature
      maxTokens
      tools
      expertise
      communicationStyle
      createdAt
      updatedAt
      team {
        aiTeamId
        workspaceId
        name
        description
        createdAt
        updatedAt
      }
    }
  }`
  const data = await request<{ aiTeamMembers: AiTeamMember[] }>(q, { workspaceId })
  return data.aiTeamMembers ?? []
}

export async function fetchScratchpadNotes(workspaceId: string): Promise<ScratchpadNote[]> {
  const q = 'query ScratchpadNotes($workspaceId: UUID!) { ' +
    'scratchpadNotes(where: { workspaceId: { eq: $workspaceId }}) { ' +
    'scratchpadNoteId workspaceId title text createdOn } }'
  const data = await request<{ scratchpadNotes: ScratchpadNote[] }>(q, { workspaceId })
  return data.scratchpadNotes ?? []
}

export async function fetchScratchpadAttachments(workspaceId: string): Promise<ScratchpadAttachment[]> {
  const q = 'query ScratchpadAttachments($workspaceId: UUID!) { ' +
    'scratchpadAttachments(where: { workspaceId: { eq: $workspaceId }}) { ' +
    'scratchpadAttachmentId workspaceId title description uri size fileType createdOn processingStatus processingError } }'
  const data = await request<{ scratchpadAttachments: ScratchpadAttachment[] }>(q, { workspaceId })
  return data.scratchpadAttachments ?? []
}

export async function fetchScratchpadAttachmentAssertions(scratchpadAttachmentId: string): Promise<ScratchpadAttachmentAssertion[]> {
  const q = `query LoadAssertions($scratchpadAttachmentId: UUID!) {
    scratchpadAttachmentAssertions(scratchpadAttachmentId: $scratchpadAttachmentId)
  }`
  const data = await request<{ scratchpadAttachmentAssertions: string }>(q, { scratchpadAttachmentId })
  const jsonString = data.scratchpadAttachmentAssertions
  if (!jsonString) {
    return []
  }
  try {
    const parsed = JSON.parse(jsonString) as ScratchpadAttachmentAssertion[]
    return Array.isArray(parsed) ? parsed : []
  } catch (error) {
    console.error('Failed to parse assertions JSON:', error)
    throw new Error('Failed to parse assertions data')
  }
}

export async function createScratchpadNote(args: { workspaceId: string; title: string; text: string }): Promise<string> {
  const q = 'mutation CreateScratchpadNote($workspaceId: UUID!, $title: String!, $text: String!) { ' +
    'createScratchpadNote(workspaceId: $workspaceId, title: $title, text: $text) }'
  const data = await request<{ createScratchpadNote: string }>(q, args)
  return data.createScratchpadNote
}

export async function deleteScratchpadNote(scratchpadNoteId: string): Promise<boolean> {
  const q = 'mutation DeleteScratchpadNote($scratchpadNoteId: UUID!) { ' +
    'deleteScratchpadNote(scratchpadNoteId: $scratchpadNoteId) }'
  const data = await request<{ deleteScratchpadNote: boolean }>(q, { scratchpadNoteId })
  return !!data.deleteScratchpadNote
}

export async function createScratchpadAttachment(args: { workspaceId: string; title?: string | null; description?: string | null; file: File }): Promise<string> {
  const q = 'mutation CreateScratchpadAttachment($workspaceId: UUID!, $title: String!, $description: String, $file: Upload!) { ' +
    'createScratchpadAttachment(workspaceId: $workspaceId, title: $title, description: $description, file: $file) }'
  const data = await requestMultipart<{ createScratchpadAttachment: string }>(q, args, 'file')
  return data.createScratchpadAttachment
}

export async function deleteScratchpadAttachment(scratchpadAttachmentId: string): Promise<boolean> {
  const q = 'mutation DeleteScratchpadAttachment($scratchpadAttachmentId: UUID!) { ' +
    'deleteScratchpadAttachment(scratchpadAttachmentId: $scratchpadAttachmentId) }'
  const data = await request<{ deleteScratchpadAttachment: boolean }>(q, { scratchpadAttachmentId })
  return !!data.deleteScratchpadAttachment
}

export async function startDocumentIndexingPipeline(scratchpadAttachmentId: string): Promise<boolean> {
  const q = 'mutation StartDocumentIndexing($scratchpadAttachmentId: UUID!) { ' +
    'startDocumentIndexingPipeline(scratchpadAttachmentId: $scratchpadAttachmentId) }'
  const data = await request<{ startDocumentIndexingPipeline: boolean }>(q, { scratchpadAttachmentId })
  return !!data.startDocumentIndexingPipeline
}

export async function startOntologyCreationPipeline(
  workspaceId: string,
  ontologyId: string,
  initialContext?: string
): Promise<{ runId: string; success: boolean }> {
  const q = `mutation StartOntologyCreation($workspaceId: UUID!, $ontologyId: UUID!, $initialContext: String) {
    startOntologyCreationPipeline(workspaceId: $workspaceId, ontologyId: $ontologyId, initialContext: $initialContext) {
      runId
      success
    }
  }`
  const data = await request<{
    startOntologyCreationPipeline: { runId: string; success: boolean }
  }>(q, { workspaceId, ontologyId, initialContext })
  return data.startOntologyCreationPipeline
}

export async function createOntology(
  tenantId: string,
  name: string,
  description?: string,
  semVer?: string,
  createdBy?: string,
  status?: string
): Promise<string> {
  const q = `mutation CreateOntology($tenantId: UUID!, $name: String!, $description: String, $semVer: String, $createdBy: UUID, $status: String) {
    createOntology(tenantId: $tenantId, name: $name, description: $description, semVer: $semVer, createdBy: $createdBy, status: $status)
  }`
  const data = await request<{ createOntology: string }>(q, {
    tenantId,
    name,
    description,
    semVer,
    createdBy,
    status,
  })
  return data.createOntology
}

export async function updateOntology(
  ontologyId: string,
  name?: string,
  description?: string,
  semVer?: string,
  status?: string,
  runId?: string,
  domainExamples?: string | null
): Promise<boolean> {
  const q = `mutation UpdateOntology($ontologyId: UUID!, $name: String, $description: String, $semVer: String, $status: String, $runId: UUID, $domainExamples: String) {
    updateOntology(ontologyId: $ontologyId, name: $name, description: $description, semVer: $semVer, status: $status, runId: $runId, domainExamples: $domainExamples)
  }`
  const data = await request<{ updateOntology: boolean }>(q, {
    ontologyId,
    name,
    description,
    semVer,
    status,
    runId,
    domainExamples: domainExamples ?? undefined,
  })
  return data.updateOntology
}

export async function deleteOntology(ontologyId: string): Promise<boolean> {
  const q = `mutation DeleteOntology($ontologyId: UUID!) {
    deleteOntology(ontologyId: $ontologyId)
  }`
  const data = await request<{ deleteOntology: boolean }>(q, { ontologyId })
  return data.deleteOntology
}

export type SyncOntologyRangesResult = {
  entitiesCreated: number
  entitiesUpdated: number
  fieldsWithRangeUpdated: number
}

export async function syncOntologyToSemanticEntities(ontologyId: string): Promise<SyncOntologyRangesResult> {
  const q = `mutation SyncOntologyRanges($ontologyId: UUID!) {
    syncOntologyToSemanticEntities(ontologyId: $ontologyId) {
      entitiesCreated
      entitiesUpdated
      fieldsWithRangeUpdated
    }
  }`
  const data = await request<{ syncOntologyToSemanticEntities: SyncOntologyRangesResult }>(q, { ontologyId })
  return data.syncOntologyToSemanticEntities
}

/**
 * Clone an ontology: creates a new ontology with the same metadata and draft JSON.
 * Neo4j connection and intents are not copied. Returns the new ontology's UUID.
 */
export async function cloneOntology(args: {
  sourceOntologyId: string
  tenantId: string
  name?: string | null
}): Promise<string> {
  const q = `mutation CloneOntology($sourceOntologyId: UUID!, $tenantId: UUID!, $name: String) {
    cloneOntology(sourceOntologyId: $sourceOntologyId, tenantId: $tenantId, name: $name)
  }`
  const data = await request<{ cloneOntology: string }>(q, {
    sourceOntologyId: args.sourceOntologyId,
    tenantId: args.tenantId,
    name: args.name?.trim() || undefined,
  })
  const id = data.cloneOntology
  if (!id) throw new Error('No ontologyId returned from clone')
  return id
}

export type SetOntologyNeo4jConnectionInput = {
  uri: string
  username: string
  password: string
}

export type Ontology = {
  ontologyId: string
  tenantId: string
  name: string
  description: string | null
  semVer: string
  createdOn: string
  createdBy: string | null
  lastEdit: string | null
  lastEditedBy: string | null
  status: string
  runId: string | null
  jsonUri: string | null
  domainExamples: string | null
}

export type Company = {
  companyId: string
  tenantId: string
  name: string
  markdownContent: string | null
}

// Intent manifest (operations third-party agents can perform).
// Frontend uses snake_case (intent, data_source, input_schema, output_schema, updatedAt);
// API returns camelCase (intentName, dataSource, inputSchema, outputSchema, lastEdit, ontologyId) â€“ we map in the layer below.
export type Intent = {
  intentId: string
  tenantId: string
  ontologyId: string | null
  ontologyName: string | null
  opId: string
  intent: string
  route: string | null
  description: string | null
  data_source: string | null
  input_schema: Record<string, unknown> | null
  output_schema: Record<string, unknown> | null
  grounding: string | null
  createdOn: string
  updatedAt: string
}

/** Raw Intent shape from API (camelCase, schema/grounding as strings). */
type IntentApi = {
  intentId: string
  tenantId: string
  ontologyId?: string | null
  ontology?: { ontologyId: string; name: string } | null
  opId: string
  intentName: string
  route: string | null
  description: string | null
  dataSource: string | null
  inputSchema: string | null
  outputSchema: string | null
  grounding: string | null
  createdOn: string
  lastEdit: string | null
}

function mapApiIntentToIntent(api: IntentApi): Intent {
  let input_schema: Record<string, unknown> | null = null
  let output_schema: Record<string, unknown> | null = null
  if (api.inputSchema != null && api.inputSchema.trim() !== '') {
    try {
      input_schema = JSON.parse(api.inputSchema) as Record<string, unknown>
    } catch {
      input_schema = null
    }
  }
  if (api.outputSchema != null && api.outputSchema.trim() !== '') {
    try {
      output_schema = JSON.parse(api.outputSchema) as Record<string, unknown>
    } catch {
      output_schema = null
    }
  }
  return {
    intentId: api.intentId,
    tenantId: api.tenantId,
    ontologyId: api.ontologyId ?? null,
    ontologyName: api.ontology?.name ?? null,
    opId: api.opId,
    intent: api.intentName,
    route: api.route ?? null,
    description: api.description ?? null,
    data_source: api.dataSource ?? null,
    input_schema,
    output_schema,
    grounding: api.grounding ?? null,
    createdOn: api.createdOn,
    updatedAt: api.lastEdit ?? api.createdOn,
  }
}

const INTENT_FIELDS = `
  intentId
  tenantId
  ontologyId
  ontology { ontologyId name }
  opId
  intentName
  route
  description
  dataSource
  inputSchema
  outputSchema
  grounding
  createdOn
  lastEdit
`

export async function listCompanies(): Promise<Company[]> {
  const q = `query ListCompanies {
    companies {
      companyId
      tenantId
      name
      markdownContent
    }
  }`
  const data = await request<{ companies: Company[] }>(q)
  return data.companies
}

export async function fetchIntents(): Promise<Intent[]> {
  const q = `query Intents { intents { ${INTENT_FIELDS} } }`
  const data = await request<{ intents: IntentApi[] }>(q)
  return (data.intents ?? []).map(mapApiIntentToIntent)
}

export async function fetchIntentById(intentId: string): Promise<Intent | null> {
  const q = `query GetIntent($intentId: UUID!) { intentById(intentId: $intentId) { ${INTENT_FIELDS} } }`
  const data = await request<{ intentById: IntentApi | null }>(q, { intentId })
  const api = data.intentById
  return api ? mapApiIntentToIntent(api) : null
}

export async function createIntent(args: {
  tenantId: string
  opId: string
  intent: string
  route?: string | null
  description?: string | null
  data_source?: string | null
  input_schema?: Record<string, unknown> | null
  output_schema?: Record<string, unknown> | null
  grounding?: string | null
  ontologyId?: string | null
}): Promise<string> {
  const q = `mutation CreateIntent(
    $tenantId: UUID!
    $opId: String!
    $intentName: String!
    $route: String
    $description: String
    $dataSource: String
    $inputSchema: String
    $outputSchema: String
    $grounding: String
    $ontologyId: UUID
  ) {
    createIntent(
      tenantId: $tenantId
      opId: $opId
      intentName: $intentName
      route: $route
      description: $description
      dataSource: $dataSource
      inputSchema: $inputSchema
      outputSchema: $outputSchema
      grounding: $grounding
      ontologyId: $ontologyId
    )
  }`
  const data = await request<{ createIntent: string }>(q, {
    tenantId: args.tenantId,
    opId: args.opId,
    intentName: args.intent,
    route: args.route ?? null,
    description: args.description ?? null,
    dataSource: args.data_source ?? null,
    inputSchema: args.input_schema != null ? JSON.stringify(args.input_schema) : null,
    outputSchema: args.output_schema != null ? JSON.stringify(args.output_schema) : null,
    grounding: args.grounding ?? null,
    ontologyId: args.ontologyId ?? null,
  })
  const id = data.createIntent
  if (!id) throw new Error('No intentId returned')
  return id
}

export async function updateIntent(args: {
  intentId: string
  opId: string
  intent: string
  route?: string | null
  description?: string | null
  data_source?: string | null
  input_schema?: Record<string, unknown> | null
  output_schema?: Record<string, unknown> | null
  grounding?: string | null
  ontologyId?: string | null
}): Promise<boolean> {
  const q = `mutation UpdateIntent(
    $intentId: UUID!
    $opId: String!
    $intentName: String!
    $route: String
    $description: String
    $dataSource: String
    $inputSchema: String
    $outputSchema: String
    $grounding: String
    $ontologyId: UUID
  ) {
    updateIntent(
      intentId: $intentId
      opId: $opId
      intentName: $intentName
      route: $route
      description: $description
      dataSource: $dataSource
      inputSchema: $inputSchema
      outputSchema: $outputSchema
      grounding: $grounding
      ontologyId: $ontologyId
    )
  }`
  const data = await request<{ updateIntent: boolean }>(q, {
    intentId: args.intentId,
    opId: args.opId,
    intentName: args.intent,
    route: args.route ?? null,
    description: args.description ?? null,
    dataSource: args.data_source ?? null,
    inputSchema: args.input_schema != null ? JSON.stringify(args.input_schema) : null,
    outputSchema: args.output_schema != null ? JSON.stringify(args.output_schema) : null,
    grounding: args.grounding ?? null,
    ontologyId: args.ontologyId ?? null,
  })
  return !!data.updateIntent
}

export async function deleteIntent(intentId: string): Promise<boolean> {
  const q = `mutation DeleteIntent($intentId: UUID!) { deleteIntent(intentId: $intentId) }`
  const data = await request<{ deleteIntent: boolean }>(q, { intentId })
  return !!data.deleteIntent
}

// ---------------------------------------------------------------------------
// Agent Roles (profiles for what incoming agents can do)
// ---------------------------------------------------------------------------

export type AgentRoleAccessKey = {
  accessKeyId: string
  keyPrefix: string
  name: string | null
  createdOn: string
  expiresAt: string | null
}

export type GenerateAgentRoleAccessKeyResult = {
  accessKeyId: string
  secretKey: string
  keyPrefix: string
  expiresAt: string | null
}

export type AgentRoleIntentRef = {
  intentId: string
  opId: string
  intentName: string
}

/** Agent role for list view (with ontology names). */
export type AgentRole = {
  agentRoleId: string
  tenantId: string
  name: string
  description: string | null
  readOntologyId: string | null
  writeOntologyId: string | null
  readOntologyName: string | null
  writeOntologyName: string | null
  createdOn: string
  lastEdit: string | null
}

/** Agent role for detail/edit (includes intents and accessKeys). */
export type AgentRoleDetail = AgentRole & {
  intents: AgentRoleIntentRef[]
  accessKeys: AgentRoleAccessKey[]
}

type AgentRoleApi = {
  agentRoleId: string
  tenantId: string
  name: string
  description: string | null
  readOntologyId: string | null
  writeOntologyId: string | null
  readOntology?: { ontologyId: string; name: string } | null
  writeOntology?: { ontologyId: string; name: string } | null
  createdOn: string
  lastEdit: string | null
}

type AgentRoleDetailApi = AgentRoleApi & {
  intents?: { intentId: string; opId: string; intentName: string }[]
  accessKeys?: { accessKeyId: string; keyPrefix: string; name: string | null; createdOn: string; expiresAt: string | null }[]
}

function mapAgentRoleApiToAgentRole(api: AgentRoleApi): AgentRole {
  return {
    agentRoleId: api.agentRoleId,
    tenantId: api.tenantId,
    name: api.name,
    description: api.description ?? null,
    readOntologyId: api.readOntologyId ?? null,
    writeOntologyId: api.writeOntologyId ?? null,
    readOntologyName: api.readOntology?.name ?? null,
    writeOntologyName: api.writeOntology?.name ?? null,
    createdOn: api.createdOn,
    lastEdit: api.lastEdit ?? null,
  }
}

const AGENT_ROLE_LIST_FIELDS = `
  agentRoleId
  tenantId
  name
  description
  readOntologyId
  writeOntologyId
  readOntology { ontologyId name }
  writeOntology { ontologyId name }
  createdOn
  lastEdit
`

const AGENT_ROLE_DETAIL_FIELDS = `
  agentRoleId
  tenantId
  name
  description
  readOntologyId
  writeOntologyId
  readOntology { ontologyId name }
  writeOntology { ontologyId name }
  createdOn
  lastEdit
  intents { intentId opId intentName }
  accessKeys { accessKeyId keyPrefix name createdOn expiresAt }
`

export async function fetchAgentRoles(): Promise<AgentRole[]> {
  const q = `query AgentRoles { agentRoles { ${AGENT_ROLE_LIST_FIELDS} } }`
  const data = await request<{ agentRoles: AgentRoleApi[] }>(q)
  return (data.agentRoles ?? []).map(mapAgentRoleApiToAgentRole)
}

export async function fetchAgentRoleById(agentRoleId: string): Promise<AgentRoleDetail | null> {
  const q = `query GetAgentRole($agentRoleId: UUID!) { agentRoleById(agentRoleId: $agentRoleId) { ${AGENT_ROLE_DETAIL_FIELDS} } }`
  const data = await request<{ agentRoleById: AgentRoleDetailApi | null }>(q, { agentRoleId })
  const api = data.agentRoleById
  if (!api) return null
  const base = mapAgentRoleApiToAgentRole(api)
  return {
    ...base,
    intents: api.intents ?? [],
    accessKeys: api.accessKeys ?? [],
  }
}

export async function createAgentRole(args: {
  tenantId: string
  name: string
  description?: string | null
  readOntologyId?: string | null
  writeOntologyId?: string | null
}): Promise<string> {
  const q = `mutation CreateAgentRole($tenantId: UUID!, $name: String!, $description: String, $readOntologyId: UUID, $writeOntologyId: UUID) {
    createAgentRole(tenantId: $tenantId, name: $name, description: $description, readOntologyId: $readOntologyId, writeOntologyId: $writeOntologyId)
  }`
  const data = await request<{ createAgentRole: string }>(q, {
    tenantId: args.tenantId,
    name: args.name,
    description: args.description ?? null,
    readOntologyId: args.readOntologyId ?? null,
    writeOntologyId: args.writeOntologyId ?? null,
  })
  const id = data.createAgentRole
  if (!id) throw new Error('No agentRoleId returned')
  return id
}

export async function updateAgentRole(args: {
  agentRoleId: string
  name: string
  description?: string | null
  readOntologyId?: string | null
  writeOntologyId?: string | null
}): Promise<boolean> {
  const q = `mutation UpdateAgentRole($agentRoleId: UUID!, $name: String!, $description: String, $readOntologyId: UUID, $writeOntologyId: UUID) {
    updateAgentRole(agentRoleId: $agentRoleId, name: $name, description: $description, readOntologyId: $readOntologyId, writeOntologyId: $writeOntologyId)
  }`
  const data = await request<{ updateAgentRole: boolean }>(q, {
    agentRoleId: args.agentRoleId,
    name: args.name,
    description: args.description ?? null,
    readOntologyId: args.readOntologyId ?? null,
    writeOntologyId: args.writeOntologyId ?? null,
  })
  return !!data.updateAgentRole
}

export async function deleteAgentRole(agentRoleId: string): Promise<boolean> {
  const q = `mutation DeleteAgentRole($agentRoleId: UUID!) { deleteAgentRole(agentRoleId: $agentRoleId) }`
  const data = await request<{ deleteAgentRole: boolean }>(q, { agentRoleId })
  return !!data.deleteAgentRole
}

export async function setAgentRoleIntents(agentRoleId: string, intentIds: string[]): Promise<boolean> {
  const q = `mutation SetAgentRoleIntents($agentRoleId: UUID!, $intentIds: [UUID!]!) {
    setAgentRoleIntents(agentRoleId: $agentRoleId, intentIds: $intentIds)
  }`
  const data = await request<{ setAgentRoleIntents: boolean }>(q, { agentRoleId, intentIds })
  return !!data.setAgentRoleIntents
}

export async function generateAgentRoleAccessKey(
  agentRoleId: string,
  name?: string | null,
  expiresAt?: string | null
): Promise<GenerateAgentRoleAccessKeyResult> {
  const q = `mutation GenerateAgentRoleAccessKey($agentRoleId: UUID!, $name: String, $expiresAt: DateTime) {
    generateAgentRoleAccessKey(agentRoleId: $agentRoleId, name: $name, expiresAt: $expiresAt) {
      accessKeyId
      secretKey
      keyPrefix
      expiresAt
    }
  }`
  const data = await request<{ generateAgentRoleAccessKey: GenerateAgentRoleAccessKeyResult }>(q, {
    agentRoleId,
    name: name ?? null,
    expiresAt: expiresAt ?? null,
  })
  return data.generateAgentRoleAccessKey
}

export async function revokeAgentRoleAccessKey(accessKeyId: string): Promise<boolean> {
  const q = `mutation RevokeAgentRoleAccessKey($accessKeyId: UUID!) { revokeAgentRoleAccessKey(accessKeyId: $accessKeyId) }`
  const data = await request<{ revokeAgentRoleAccessKey: boolean }>(q, { accessKeyId })
  return !!data.revokeAgentRoleAccessKey
}

export async function fetchOntologies(): Promise<Ontology[]> {
  const q = `query Ontologies {
    ontologies {
      ontologyId
      tenantId
      name
      description
      semVer
      createdOn
      createdBy
      lastEdit
      lastEditedBy
      status
      runId
      jsonUri
      domainExamples
    }
  }`
  const data = await request<{ ontologies: Ontology[] }>(q)
  return data.ontologies
}

export async function fetchOntologyPackage(ontologyId: string): Promise<import('../types/ontology').OntologyPackage | null> {
  const q = `query OntologyJson($ontologyId: UUID!) {
    ontologyJson(ontologyId: $ontologyId)
  }`
  const data = await request<{ ontologyJson: string }>(q, { ontologyId })
  if (!data.ontologyJson) return null
  try {
    return JSON.parse(data.ontologyJson) as import('../types/ontology').OntologyPackage
  } catch (e) {
    console.error('Failed to parse ontology JSON:', e)
    return null
  }
}

export async function fetchScratchpadAttachmentById(scratchpadAttachmentId: string): Promise<ScratchpadAttachment | null> {
  const q = 'query ScratchpadAttachmentById($scratchpadAttachmentId: UUID!) { ' +
    'scratchpadAttachmentById(scratchpadAttachmentId: $scratchpadAttachmentId) { ' +
    'scratchpadAttachmentId workspaceId title description uri size fileType createdOn processingStatus processingError } }'
  const data = await request<{ scratchpadAttachmentById: ScratchpadAttachment | null }>(q, { scratchpadAttachmentId })
  return data.scratchpadAttachmentById ?? null
}

// Data Loading mutations and queries
export async function createDataLoadingAttachment(
  tenantId: string,
  ontologyId: string,
  file: File,
  fileName?: string | null
): Promise<string> {
  const q = 'mutation CreateDataLoadingAttachment($tenantId: UUID!, $ontologyId: UUID!, $file: Upload!, $fileName: String) { ' +
    'createDataLoadingAttachment(tenantId: $tenantId, ontologyId: $ontologyId, file: $file, fileName: $fileName) }'
  const variables: Record<string, any> = {
    tenantId,
    ontologyId,
    file,
    fileName: fileName || null,
  }
  const data = await requestMultipart<{ createDataLoadingAttachment: string }>(q, variables, 'file')
  return data.createDataLoadingAttachment
}

export async function dataLoadingAttachments(tenantId?: string, ontologyId?: string): Promise<DataLoadingAttachment[]> {
  const variables: Record<string, any> = {}
  const whereParts: string[] = []
  const varDeclarations: string[] = []

  if (tenantId) {
    variables.tenantId = tenantId
    varDeclarations.push('$tenantId: UUID!')
    whereParts.push('tenantId: { eq: $tenantId }')
  }
  if (ontologyId) {
    variables.ontologyId = ontologyId
    varDeclarations.push('$ontologyId: UUID!')
    whereParts.push('ontologyId: { eq: $ontologyId }')
  }

  const varClause = varDeclarations.length > 0 ? `(${varDeclarations.join(', ')})` : ''
  const whereClause = whereParts.length > 0 ? `(where: { ${whereParts.join(', ')} })` : ''

  const q = `query DataLoadingAttachments${varClause} {
    dataLoadingAttachments${whereClause} {
      attachmentId
      tenantId
      ontologyId
      fileName
      blobPath
      uri
      createdOn
      createdBy
      runId
      status
    }
  }`

  const data = await request<{ dataLoadingAttachments: DataLoadingAttachment[] }>(q, variables)
  return data.dataLoadingAttachments
}

export async function dataLoadingAttachmentById(attachmentId: string): Promise<DataLoadingAttachment | null> {
  const q = 'query DataLoadingAttachmentById($attachmentId: UUID!) { ' +
    'dataLoadingAttachmentById(attachmentId: $attachmentId) { ' +
    'attachmentId tenantId ontologyId fileName blobPath uri createdOn createdBy runId status } }'
  const data = await request<{ dataLoadingAttachmentById: DataLoadingAttachment | null }>(q, { attachmentId })
  return data.dataLoadingAttachmentById ?? null
}

export async function startDataLoadingPipeline(
  dataLoadingAttachmentId: string,
  workspaceId: string,
  initialInstructions?: string | null
): Promise<StartDataLoadingResult> {
  const q = `mutation StartDataLoadingPipeline($dataLoadingAttachmentId: UUID!, $workspaceId: UUID!, $initialInstructions: String) {
    startDataLoadingPipeline(dataLoadingAttachmentId: $dataLoadingAttachmentId, workspaceId: $workspaceId, initialInstructions: $initialInstructions) {
      runId
      success
    }
  }`
  const data = await request<{
    startDataLoadingPipeline: StartDataLoadingResult
  }>(q, { dataLoadingAttachmentId, workspaceId, initialInstructions: initialInstructions || null })
  return data.startDataLoadingPipeline
}

export async function deleteDataLoadingAttachment(attachmentId: string): Promise<boolean> {
  const q = 'mutation DeleteDataLoadingAttachment($attachmentId: UUID!) { ' +
    'deleteDataLoadingAttachment(attachmentId: $attachmentId) }'
  const data = await request<{ deleteDataLoadingAttachment: boolean }>(q, { attachmentId })
  return !!data.deleteDataLoadingAttachment
}

export async function setOntologyNeo4jConnection(
  tenantId: string,
  ontologyId: string,
  input: SetOntologyNeo4jConnectionInput
): Promise<boolean> {
  const q = `mutation SetOntologyNeo4j($tenantId: UUID!, $ontologyId: UUID!, $input: SetOntologyNeo4jConnectionInput!) {
    setOntologyNeo4jConnection(tenantId: $tenantId, ontologyId: $ontologyId, input: $input)
  }`
  const data = await request<{ setOntologyNeo4jConnection: boolean }>(q, {
    tenantId,
    ontologyId,
    input,
  })
  return !!data.setOntologyNeo4jConnection
}

// Workspace mutations
export async function createWorkspace(args: {
  name: string
  companyId?: string | null
  ontologyId?: string | null
}): Promise<string> {
  const q =
    'mutation CreateWorkspaceWithCompanyAndOntology($name: String!, $companyId: UUID, $ontologyId: UUID) { ' +
    'createWorkspace(name: $name, description: "My workspace", intent: "Analysis", companyId: $companyId, ontologyId: $ontologyId) }'
  const variables = {
    name: args.name,
    companyId: args.companyId ?? null,
    ontologyId: args.ontologyId ?? null,
  }
  const data = await request<{ createWorkspace: string }>(q, variables)
  const id = data.createWorkspace
  if (!id) throw new Error('No workspaceId returned')
  return id
}

export async function deleteWorkspace(workspaceId: string): Promise<boolean> {
  const q = 'mutation DeleteWorkspace($workspaceId: UUID!) { ' +
    'deleteWorkspace(workspaceId: $workspaceId) }'
  const data = await request<{ deleteWorkspace: boolean }>(q, { workspaceId })
  return !!data.deleteWorkspace
}

export async function updateWorkspace(args: {
  workspaceId: string
  name?: string | null
  description?: string | null
  intent?: string | null
  visibility?: string | null
  baseSnapshotTs?: string | null
  state?: string | null
}): Promise<boolean> {
  const q = 'mutation UpdateWorkspace(' +
    '$workspaceId: UUID!, $name: String, $description: String, $intent: String, $visibility: String, $baseSnapshotTs: DateTime, $state: String' +
    ') { ' +
    'updateWorkspace(workspaceId: $workspaceId, name: $name, description: $description, intent: $intent, visibility: $visibility, baseSnapshotTs: $baseSnapshotTs, state: $state)' +
    ' }'
  const data = await request<{ updateWorkspace: boolean }>(q, args)
  return !!data.updateWorkspace
}

// Add graph node to a workspace
export async function addWorkspaceNode(args: {
  workspaceId: string
  graphNodeId: string
  graphEdgeId?: string | null
  labels?: string[]
  pinnedBy: string
}): Promise<boolean> {
  const q = 'mutation AddWorkspaceNode(' +
    '$workspaceId: UUID!, $graphNodeId: String!, $graphEdgeId: String, $labels: [String!], $pinnedBy: UUID!' +
    ') { ' +
    'addWorkspaceNode(workspaceId: $workspaceId, graphNodeId: $graphNodeId, graphEdgeId: $graphEdgeId, labels: $labels, pinnedBy: $pinnedBy) {' +
      ' workspaceItemId workspaceId graphNodeId graphEdgeId labels pinnedBy pinnedAt ' +
    '} }'
  const data = await request<{ addWorkspaceNode: any }>(q, args)
  return !!data.addWorkspaceNode
}

// Delete a workspace item (node or edge). Provide either graphNodeId or graphEdgeId.
export async function deleteWorkspaceItem(args: {
  workspaceId: string
  graphNodeId: string
  graphEdgeId?: string | null
}): Promise<boolean> {
  const q = 'mutation DeleteWorkspaceItem(' +
    '$workspaceId: UUID!, $graphNodeId: String!, $graphEdgeId: String' +
    ') { ' +
    'deleteWorkspaceItem(workspaceId: $workspaceId, graphNodeId: $graphNodeId, graphEdgeId: $graphEdgeId)' +
    ' }'
  const data = await request<{ deleteWorkspaceItem: boolean }>(q, args)
  return !!data.deleteWorkspaceItem
}

// Workspace Setup Operations (per WORKSPACE_SETUP_PLAN.md)

export async function startWorkspaceSetup(workspaceId: string, initialMessage?: string): Promise<StageTransitionResult> {
  const q = 'mutation StartWorkspaceSetup($workspaceId: UUID!, $initialMessage: String) { ' +
    'startWorkspaceSetup(workspaceId: $workspaceId, initialMessage: $initialMessage) { runId stage } }'
  const data = await request<{ startWorkspaceSetup: StageTransitionResult }>(q, { workspaceId, initialMessage })
  return data.startWorkspaceSetup
}

export async function confirmIntentAndStartDataScoping(
  workspaceId: string,
  intentPackage: IntentPackage
): Promise<StageTransitionResult> {
  // Backend expects intentPackage as a JSON string, not an input object
  const q = 'mutation ConfirmIntentAndStartDataScoping($workspaceId: UUID!, $intentPackage: String!) { ' +
    'confirmIntentAndStartDataScoping(workspaceId: $workspaceId, intentPackage: $intentPackage) { runId stage } }'
  const data = await request<{ confirmIntentAndStartDataScoping: StageTransitionResult }>(
    q,
    { workspaceId, intentPackage: JSON.stringify(intentPackage) }
  )
  return data.confirmIntentAndStartDataScoping
}

export async function confirmDataScopeAndStartExecution(
  workspaceId: string,
  dataScope: DataScope
): Promise<StageTransitionResult> {
  // Backend expects dataScope as a JSON string, not an input object
  const q = 'mutation ConfirmDataScopeAndStartExecution($workspaceId: UUID!, $dataScope: String!) { ' +
    'confirmDataScopeAndStartExecution(workspaceId: $workspaceId, dataScope: $dataScope) { runId stage } }'
  const data = await request<{ confirmDataScopeAndStartExecution: StageTransitionResult }>(
    q,
    { workspaceId, dataScope: JSON.stringify(dataScope) }
  )
  return data.confirmDataScopeAndStartExecution
}

export async function confirmDataReviewAndBuildTeam(
  workspaceId: string,
  executionResults: ExecutionResult[]
): Promise<StageTransitionResult> {
  const q = 'mutation ConfirmDataReviewAndBuildTeam($workspaceId: UUID!, $executionResults: String!) { ' +
    'confirmDataReviewAndBuildTeam(workspaceId: $workspaceId, executionResults: $executionResults) { runId stage } }'
  const data = await request<{ confirmDataReviewAndBuildTeam: StageTransitionResult }>(
    q,
    { workspaceId, executionResults: JSON.stringify(executionResults) }
  )
  return data.confirmDataReviewAndBuildTeam
}

export async function workspaceSetupStatus(workspaceId: string): Promise<SetupStatus> {
  const q = 'query WorkspaceSetupStatus($workspaceId: UUID!) { ' +
    'workspaceSetupStatus(workspaceId: $workspaceId) { ' +
      'stage intentPackage dataScope executionResults teamConfig ' +
    '} }'
  const data = await request<{ workspaceSetupStatus: Partial<SetupStatus> }>(q, { workspaceId })
  // Add workspaceId back to the response (we already know it from input)
  // runId will come from workspace.setupRunId instead
  return {
    workspaceId,
    stage: data.workspaceSetupStatus.stage!,
    runId: null, // Will be populated from workspace.setupRunId
    intentPackage: data.workspaceSetupStatus.intentPackage || null,
    dataScope: data.workspaceSetupStatus.dataScope || null,
    executionResults: data.workspaceSetupStatus.executionResults || null,
    teamConfig: data.workspaceSetupStatus.teamConfig || null,
  }
}

export async function completeWorkspaceSetup(
  workspaceId: string,
  teamConfig: TeamConfig
): Promise<string | null> {
  const q = `mutation CompleteWorkspaceSetup($workspaceId: UUID!, $teamConfig: String!) {
    completeWorkspaceSetup(workspaceId: $workspaceId, teamConfig: $teamConfig)
  }`
  const data = await request<{ completeWorkspaceSetup: string | null }>(q, {
    workspaceId,
    teamConfig: JSON.stringify(teamConfig),
  })
  return data.completeWorkspaceSetup
}

// Feedback API types
export type FeedbackSubmission = {
  runId: string
  feedback_text: string
  action: string
  subtask_id?: string | null
  target?: any
}

export type FeedbackRequest = {
  id: string
  runId: string
  checkpoint: string
  message: string
  options?: string[]
  metadata: {
    subtasks?: Array<{
      id: string
      description: string
      agent_id: string
    }>
  }
}

export type FeedbackHistoryItem = {
  id: string
  runId: string
  feedback_text: string
  action: string
  timestamp: string
  applied: boolean
}

// GraphQL response types (matching the schema)
type GraphQLFeedbackRequest = {
  feedbackRequestId: string
  tenantId: string
  runId: string
  taskId: string | null
  checkpoint: string
  message: string
  options: string[] // [String!]! - non-nullable array
  metadata: string // String! - JSON string, required
  createdAt: string
  timeoutSeconds: number
  isResolved: boolean
  resolvedAt: string | null
}

type GraphQLFeedback = {
  feedbackId: string
  tenantId: string
  runId: string
  taskId: string | null
  feedbackRequestId: string | null
  subtaskId: string | null
  feedbackText: string
  action: string
  target: string // String! - JSON string, required
  timestamp: string
  applied: boolean
  appliedAt: string | null
}

// Submit feedback for a run
export async function submitFeedback(runId: string, feedback: FeedbackSubmission): Promise<{ feedbackId: string; timestamp: string; applied: boolean }> {
  const q = `mutation SubmitFeedback(
    $runId: UUID!
    $feedbackText: String!
    $action: String!
    $subtaskId: String
    $targetJson: String
  ) {
    submitFeedback(
      runId: $runId
      feedbackText: $feedbackText
      action: $action
      subtaskId: $subtaskId
      targetJson: $targetJson
    ) {
      feedbackId
      feedbackText
      action
      subtaskId
      target
      timestamp
      applied
      appliedAt
    }
  }`
  
  const variables: Record<string, any> = {
    runId,
    feedbackText: feedback.feedback_text,
    action: feedback.action,
  }
  
  if (feedback.subtask_id) {
    variables.subtaskId = feedback.subtask_id
  }
  
  if (feedback.target) {
    variables.targetJson = JSON.stringify(feedback.target)
  }
  
  const data = await request<{ submitFeedback: GraphQLFeedback }>(q, variables)
  // Return simplified response for backward compatibility
  return {
    feedbackId: data.submitFeedback.feedbackId,
    timestamp: data.submitFeedback.timestamp,
    applied: data.submitFeedback.applied,
  }
}

// Get active feedback request for a run
export async function getActiveFeedbackRequest(runId: string): Promise<FeedbackRequest | null> {
  const q = `query ActiveFeedbackRequest($runId: UUID!) {
    activeFeedbackRequest(runId: $runId) {
      feedbackRequestId
      tenantId
      runId
      taskId
      checkpoint
      message
      options
      metadata
      createdAt
      timeoutSeconds
      isResolved
      resolvedAt
    }
  }`
  
  try {
    const data = await request<{ activeFeedbackRequest: GraphQLFeedbackRequest | null }>(q, { runId })
    const result = data.activeFeedbackRequest
    
    if (!result || result.isResolved) {
      return null
    }
    
    // Parse metadata JSON string (required field, but handle parsing errors)
    let metadata: any = {}
    if (result.metadata) {
      try {
        metadata = JSON.parse(result.metadata)
      } catch {
        metadata = {}
      }
    }
    
    return {
      id: result.feedbackRequestId,
      runId: result.runId,
      checkpoint: result.checkpoint,
      message: result.message,
      options: result.options,
      metadata: metadata,
    }
  } catch (error: any) {
    // If the query returns null or error, return null
    if (error.message?.includes('not found') || error.message?.includes('No active')) {
      return null
    }
    throw error
  }
}

// Get feedback history for a run
export async function getFeedbackHistory(runId: string): Promise<FeedbackHistoryItem[]> {
  const q = `query GetFeedbackHistory($runId: UUID!) {
    feedbacks(
      where: { runId: { eq: $runId } }
      order: [{ timestamp: ASC }]
    ) {
      feedbackId
      tenantId
      runId
      taskId
      feedbackRequestId
      subtaskId
      feedbackText
      action
      target
      timestamp
      applied
      appliedAt
    }
  }`
  
  const data = await request<{ feedbacks: GraphQLFeedback[] }>(q, { runId })
  
  return data.feedbacks.map((item) => ({
    id: item.feedbackId,
    runId: item.runId,
    feedback_text: item.feedbackText,
    action: item.action,
    timestamp: item.timestamp,
    applied: item.applied,
  }))
}

// Append content to scenario run log
export async function appendScenarioRunLog(runId: string, content: string): Promise<boolean> {
  const q = `mutation AppendScenarioRunLog($runId: UUID!, $content: String!) {
    appendScenarioRunLog(runId: $runId, content: $content)
  }`
  const data = await request<{ appendScenarioRunLog: boolean }>(q, { runId, content })
  return !!data.appendScenarioRunLog
}

// Scenario Run types
export type ScenarioRun = {
  runId: string
  workspaceId: string
  scenarioId: string
  title: string | null
  status: string | null
  engine: string | null
  startedAt: string
}

export type WorkspaceAnalysis = {
  workspaceAnalysisId: string
  workspaceId: string
  titleText: string
  bodyText: string | null
  createdOn: string
  version: number
}

export type Scenario = {
  scenarioId: string
  workspaceId: string
  name: string
  headerText: string | null
  mainText: string | null
  createdAt: string
}

// Fetch scenario runs for a workspace
export async function fetchScenarioRuns(workspaceId: string): Promise<ScenarioRun[]> {
  const q = `query ScenarioRuns($workspaceId: UUID!) {
    scenarioRuns(where: { workspaceId: { eq: $workspaceId } }) {
      runId
      workspaceId
      scenarioId
      title
      status
      engine
      startedAt
    }
  }`
  const data = await request<{ scenarioRuns: ScenarioRun[] }>(q, { workspaceId })
  return data.scenarioRuns ?? []
}

// Get all report templates
export async function fetchReportTemplates(): Promise<Omit<ReportTemplate, 'sections'>[]> {
  const q = `query GetTemplates {
    reportTemplates {
      templateId
      version
      name
      description
      createdAt
    }
  }`
  const data = await request<{ reportTemplates: Omit<ReportTemplate, 'sections'>[] }>(q)
  return data.reportTemplates ?? []
}

// Get template with full structure
export async function fetchReportTemplateById(
  templateId: string,
  version: number
): Promise<ReportTemplate | null> {
  const q = `query GetTemplate($templateId: UUID!, $version: Int!) {
    reportTemplateById(templateId: $templateId, version: $version) {
      templateId
      version
      name
      description
      sections {
        templateSectionId
        sectionType
        header
        order
        semanticDefinition
        blocks {
          templateBlockId
          blockType
          order
          layoutHints
          semanticDefinition
        }
      }
    }
  }`
  try {
    const data = await request<{ reportTemplateById: ReportTemplate | null }>(q, {
      templateId,
      version,
    })
    return data.reportTemplateById
  } catch (error: any) {
    if (error.message?.includes('not found')) {
      return null
    }
    throw error
  }
}

// Get all reports (list view - basic info only)
export async function fetchReports(): Promise<Omit<Report, 'sections' | 'sources'>[]> {
  const q = `query GetReports {
    reports {
      reportId
      templateId
      templateVersion
      title
      status
      type
      metadata
    }
  }`
  try {
    const data = await request<{ reports: Omit<Report, 'sections' | 'sources'>[] }>(q)
    return data.reports ?? []
  } catch (error: any) {
    console.error('Failed to fetch reports:', error)
    return []
  }
}

// Get workflow API base URL
export function getWorkflowApiBase(): string {
  return import.meta.env.VITE_WORKFLOW_API_URL || 'http://localhost:8080'
}

// Map engine names to workflow names
// Engine format: "ai:workflow-name" -> workflow name: "workflow-name"
function engineToWorkflowName(engine: string): string {
  // Remove "ai:" prefix if present
  return engine.replace(/^ai:/, '')
}

// Trigger workflow directly via Python FastAPI (bypasses Service Bus)
export async function triggerWorkflow(params: {
  tenantId: string
  workspaceId: string
  scenarioId: string
  inputs: Record<string, any>
  engine?: string // e.g., "ai:workspace-analyzer", "ai:theo", "ai:data-recommender"
}): Promise<{ run_id: string; sse_url: string }> {
  const { tenantId, workspaceId, scenarioId, inputs, engine = 'ai:workspace-chat' } = params
  const workflowName = engineToWorkflowName(engine)
  const workflowApiBase = getWorkflowApiBase().replace(/\/$/, '')
  const url = `${workflowApiBase}/api/workflows/${workflowName}/trigger`

  const requestBody = {
    tenant_id: tenantId,
    workspace_id: workspaceId,
    scenario_id: scenarioId,
    inputs,
  }

  console.log('[triggerWorkflow] Triggering workflow:', {
    url,
    workflowName,
    engine,
    requestBody,
  })

  try {
    const response = await fetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(requestBody),
    })

    console.log('[triggerWorkflow] Response status:', response.status)

    if (!response.ok) {
      const errorText = await response.text()
      console.error('[triggerWorkflow] Error response:', errorText)
      throw new Error(`Failed to trigger workflow: ${response.status} ${errorText}`)
    }

    const data = await response.json()
    console.log('[triggerWorkflow] Response data:', data)

    if (!data.run_id) throw new Error('No run_id returned from workflow trigger')
    return data
  } catch (error) {
    console.error('[triggerWorkflow] Fetch error:', error)
    throw error
  }
}

// Get report with full structure
export async function fetchReportById(reportId: string): Promise<Report | null> {
  const q = `query GetReport($reportId: UUID!) {
    reportById(reportId: $reportId) {
      reportId
      templateId
      templateVersion
      title
      status
      type
      metadata
      sections {
        reportSectionId
        templateSectionId
        sectionType
        header
        order
        blocks {
          reportBlockId
          templateBlockId
          blockType
          order
          sourceRefs
          provenance
          layoutHints
        }
      }
      sources {
        sourceId
        sourceType
        uri
        title
        description
      }
    }
  }`
  try {
    const data = await request<{ reportById: Report | null }>(q, { reportId })
    return data.reportById
  } catch (error: any) {
    if (error.message?.includes('not found')) {
      return null
    }
    throw error
  }
}

// Get block content (type-specific)
export async function fetchBlockContent(
  reportBlockId: string,
  blockType: 'rich_text' | 'single_metric' | 'multi_metric' | 'insight_card'
): Promise<RichTextContent | SingleMetricContent | MultiMetricContent | InsightCardContent | null> {
  try {
    if (blockType === 'rich_text') {
      const q = `query GetRichTextContent($reportBlockId: UUID!) {
        reportBlockRichTextByBlockId(reportBlockId: $reportBlockId) {
          reportBlockId
          content
        }
      }`
      const data = await request<{ reportBlockRichTextByBlockId: RichTextContent | null }>(q, {
        reportBlockId,
      })
      return data.reportBlockRichTextByBlockId
    } else if (blockType === 'single_metric') {
      const q = `query GetSingleMetricContent($reportBlockId: UUID!) {
        reportBlockSingleMetricByBlockId(reportBlockId: $reportBlockId) {
          reportBlockId
          label
          value
          unit
          trend
        }
      }`
      const data = await request<{ reportBlockSingleMetricByBlockId: SingleMetricContent | null }>(q, {
        reportBlockId,
      })
      return data.reportBlockSingleMetricByBlockId
    } else if (blockType === 'multi_metric') {
      const q = `query GetMultiMetricContent($reportBlockId: UUID!) {
        reportBlockMultiMetricByBlockId(reportBlockId: $reportBlockId) {
          reportBlockId
          metrics
        }
      }`
      const data = await request<{ reportBlockMultiMetricByBlockId: MultiMetricContent | null }>(q, {
        reportBlockId,
      })
      return data.reportBlockMultiMetricByBlockId
    } else if (blockType === 'insight_card') {
      const q = `query GetInsightCardContent($reportBlockId: UUID!) {
        reportBlockInsightCardByBlockId(reportBlockId: $reportBlockId) {
          reportBlockId
          title
          body
          badge
          severity
        }
      }`
      const data = await request<{ reportBlockInsightCardByBlockId: InsightCardContent | null }>(q, {
        reportBlockId,
      })
      return data.reportBlockInsightCardByBlockId
    }
    return null
  } catch (error: any) {
    if (error.message?.includes('not found')) {
      return null
    }
    throw error
  }
}

// Create report from template
export async function createReport(args: {
  templateId: string
  templateVersion: number
  workspaceAnalysisId?: string | null
  scenarioId?: string | null
  type: string
  title: string
  status: string
  metadata?: string | null
}): Promise<string> {
  const q = `mutation CreateReport(
    $templateId: UUID!
    $templateVersion: Int!
    $workspaceAnalysisId: UUID
    $scenarioId: UUID
    $type: String!
    $title: String!
    $status: String!
    $metadata: String
  ) {
    createReport(
      templateId: $templateId
      templateVersion: $templateVersion
      workspaceAnalysisId: $workspaceAnalysisId
      scenarioId: $scenarioId
      type: $type
      title: $title
      status: $status
      metadata: $metadata
    )
  }`
  const data = await request<{ createReport: string }>(q, args)
  const reportId = data.createReport
  if (!reportId) throw new Error('No reportId returned')
  return reportId
}

// Create report section
export async function createReportSection(args: {
  reportId: string
  templateSectionId: string
  sectionType: string
  header: string
  order: number
}): Promise<string> {
  const q = `mutation CreateReportSection(
    $reportId: UUID!
    $templateSectionId: UUID!
    $sectionType: String!
    $header: String!
    $order: Int!
  ) {
    createReportSection(
      reportId: $reportId
      templateSectionId: $templateSectionId
      sectionType: $sectionType
      header: $header
      order: $order
    )
  }`
  const data = await request<{ createReportSection: string }>(q, args)
  const sectionId = data.createReportSection
  if (!sectionId) throw new Error('No sectionId returned')
  return sectionId
}

// Create report block
export async function createReportBlock(args: {
  reportSectionId: string
  templateBlockId: string
  blockType: string
  sourceRefs?: string[] | null
  provenance?: string | null
  layoutHints?: string | null
  order: number
}): Promise<string> {
  const q = `mutation CreateReportBlock(
    $reportSectionId: UUID!
    $templateBlockId: UUID!
    $blockType: String!
    $sourceRefs: [String!]
    $provenance: String
    $layoutHints: String
    $order: Int!
  ) {
    createReportBlock(
      reportSectionId: $reportSectionId
      templateBlockId: $templateBlockId
      blockType: $blockType
      sourceRefs: $sourceRefs
      provenance: $provenance
      layoutHints: $layoutHints
      order: $order
    )
  }`
  const data = await request<{ createReportBlock: string }>(q, args)
  const blockId = data.createReportBlock
  if (!blockId) throw new Error('No blockId returned')
  return blockId
}

// Update report section
export async function updateReportSection(args: {
  reportSectionId: string
  header?: string | null
  order?: number | null
}): Promise<boolean> {
  const q = `mutation UpdateReportSection(
    $reportSectionId: UUID!
    $header: String
    $order: Int
  ) {
    updateReportSection(
      reportSectionId: $reportSectionId
      header: $header
      order: $order
    )
  }`
  const data = await request<{ updateReportSection: boolean }>(q, args)
  return !!data.updateReportSection
}

// Update report block order
export async function updateReportBlock(args: {
  reportBlockId: string
  order?: number | null
}): Promise<boolean> {
  const q = `mutation UpdateReportBlock(
    $reportBlockId: UUID!
    $order: Int
  ) {
    updateReportBlock(
      reportBlockId: $reportBlockId
      order: $order
    )
  }`
  const data = await request<{ updateReportBlock: boolean }>(q, args)
  return !!data.updateReportBlock
}

// Delete report section
export async function deleteReportSection(reportSectionId: string): Promise<boolean> {
  const q = `mutation DeleteReportSection($reportSectionId: UUID!) {
    deleteReportSection(reportSectionId: $reportSectionId)
  }`
  const data = await request<{ deleteReportSection: boolean }>(q, { reportSectionId })
  return !!data.deleteReportSection
}

// Delete report
export async function deleteReport(reportId: string): Promise<boolean> {
  const q = `mutation DeleteReport($reportId: UUID!) {
    deleteReport(reportId: $reportId)
  }`
  const data = await request<{ deleteReport: boolean }>(q, { reportId })
  return !!data.deleteReport
}

// Upsert block content (type-specific)
export async function upsertRichText(args: {
  reportBlockId: string
  content: string
}): Promise<boolean> {
  const q = `mutation UpsertRichText(
    $reportBlockId: UUID!
    $content: String!
  ) {
    upsertReportBlockRichText(
      reportBlockId: $reportBlockId
      content: $content
    )
  }`
  const data = await request<{ upsertReportBlockRichText: boolean }>(q, args)
  return !!data.upsertReportBlockRichText
}

export async function upsertSingleMetric(args: {
  reportBlockId: string
  label: string
  value: string
  unit?: string | null
  trend?: 'up' | 'down' | 'stable' | null
}): Promise<boolean> {
  const q = `mutation UpsertSingleMetric(
    $reportBlockId: UUID!
    $label: String!
    $value: String!
    $unit: String
    $trend: String
  ) {
    upsertReportBlockSingleMetric(
      reportBlockId: $reportBlockId
      label: $label
      value: $value
      unit: $unit
      trend: $trend
    )
  }`
  const data = await request<{ upsertReportBlockSingleMetric: boolean }>(q, args)
  return !!data.upsertReportBlockSingleMetric
}

export async function upsertMultiMetric(args: {
  reportBlockId: string
  metrics: string // JSON string array
}): Promise<boolean> {
  const q = `mutation UpsertMultiMetric(
    $reportBlockId: UUID!
    $metrics: String!
  ) {
    upsertReportBlockMultiMetric(
      reportBlockId: $reportBlockId
      metrics: $metrics
    )
  }`
  const data = await request<{ upsertReportBlockMultiMetric: boolean }>(q, args)
  return !!data.upsertReportBlockMultiMetric
}

export async function upsertInsightCard(args: {
  reportBlockId: string
  title: string
  body: string
  badge?: string | null
  severity?: 'info' | 'warning' | 'critical' | null
}): Promise<boolean> {
  const q = `mutation UpsertInsightCard(
    $reportBlockId: UUID!
    $title: String!
    $body: String!
    $badge: String
    $severity: String
  ) {
    upsertReportBlockInsightCard(
      reportBlockId: $reportBlockId
      title: $title
      body: $body
      badge: $badge
      severity: $severity
    )
  }`
  const data = await request<{ upsertReportBlockInsightCard: boolean }>(q, args)
  return !!data.upsertReportBlockInsightCard
}

// Fetch workspace analyses for a workspace
export async function fetchWorkspaceAnalyses(workspaceId: string): Promise<WorkspaceAnalysis[]> {
  const q = `query GetWorkspaceAnalyses($workspaceId: UUID!) {
    workspaceAnalyses(where: { workspaceId: { eq: $workspaceId } }) {
      workspaceAnalysisId
      workspaceId
      titleText
      bodyText
      createdOn
      version
    }
  }`
  try {
    const data = await request<{ workspaceAnalyses: WorkspaceAnalysis[] }>(q, { workspaceId })
    return data.workspaceAnalyses ?? []
  } catch (error: any) {
    console.error('Failed to fetch workspace analyses:', error)
    return []
  }
}

// Fetch scenarios for a workspace
export async function fetchScenarios(workspaceId: string): Promise<Scenario[]> {
  const q = `query GetScenarios($workspaceId: UUID!) {
    scenarios(where: { workspaceId: { eq: $workspaceId } }) {
      scenarioId
      workspaceId
      name
      headerText
      mainText
      createdAt
    }
  }`
  try {
    const data = await request<{ scenarios: Scenario[] }>(q, { workspaceId })
    return data.scenarios ?? []
  } catch (error: any) {
    console.error('Failed to fetch scenarios:', error)
    return []
  }
}

// Fetch report by workspaceAnalysisId or scenarioId
export async function fetchReportByAttachment(
  workspaceAnalysisId?: string,
  scenarioId?: string
): Promise<Report | null> {
  if (!workspaceAnalysisId && !scenarioId) {
    return null
  }

  try {
    if (workspaceAnalysisId) {
      const q = `query GetReportByWorkspaceAnalysis($workspaceAnalysisId: UUID!) {
        reports(where: { workspaceAnalysisId: { eq: $workspaceAnalysisId } }) {
          reportId
          templateId
          templateVersion
          title
          status
          type
          metadata
          workspaceAnalysisId
          scenarioId
        }
      }`
      const data = await request<{ reports: Omit<Report, 'sections' | 'sources'>[] }>(q, { workspaceAnalysisId })
      return (data.reports?.[0] as unknown as Report) ?? null
    } else {
      const q = `query GetReportByScenario($scenarioId: UUID!) {
        reports(where: { scenarioId: { eq: $scenarioId } }) {
          reportId
          templateId
          templateVersion
          title
          status
          type
          metadata
          workspaceAnalysisId
          scenarioId
        }
      }`
      const data = await request<{ reports: Omit<Report, 'sections' | 'sources'>[] }>(q, { scenarioId })
      return (data.reports?.[0] as unknown as Report) ?? null
    }
  } catch (error: any) {
    console.error('Failed to fetch report by attachment:', error)
    return null
  }
}